---
title: 堆区、栈区、静态区、和代码区
date: 2024-06-06T23:50:51Z
tags: []
---

1. **堆区（Heap）** ：

   - **特点：** 堆区是动态分配的内存空间，用于存储程序运行时动态分配的数据。在堆区分配的内存需要手动释放，否则可能导致内存泄漏。
   - **分配和释放：** 通过 `malloc`、`calloc`、`realloc` 等函数分配，通过 `free` 函数释放。

2. **栈区（Stack）** ：

   - **特点：** 栈区用于存储函数调用时的局部变量、函数参数和函数调用的返回地址等。它是一种后进先出（LIFO）的数据结构。
   - **分配和释放：** 由编译器自动分配和释放，不需要手动管理。

3. **静态区（Static）** ：

   - **特点：** 静态区分为全局静态区和局部静态区。全局静态区用于存储全局变量和静态变量，而局部静态区用于存储在函数中定义的静态变量。
   - **分配和释放：** 由编译器分配，程序运行期间一直存在。

4. **代码区（Code）** ：

   - **特点：** 代码区存储程序的执行代码。这是只读区域，存储了程序的二进制代码。
   - **分配和释放：** 由操作系统和加载器负责，无需手动管理。

&nbsp;

&nbsp;

1. **带** **​`static`​**​ **关键字的全局静态变量：**

   ```c
   // 全局静态变量
   static int globalStaticVar = 42;
   int main() {
   // 在任何函数中都可以访问 globalStaticVar
   }
   ```

   这样定义的全局静态变量 `globalStaticVar`​ 具有文件作用域，即在整个源文件中可见，但是对其他源文件是不可见的。其他源文件中可以定义同名的全局变量，而不会产生冲突。

2. **不带** **​`static`​**​ **关键字的全局静态变量：**

   ```c
   // 全局静态变量
   int globalStaticVar = 42;
   int main() {
     // 在任何函数中都可以访问 globalStaticVar
   }
   ```

   如果去掉 `static`​ 关键字，全局静态变量 `globalStaticVar`​ 将具有全局作用域，即在整个程序中可见，包括其他源文件。这可能导致命名冲突，因为其他源文件也可以定义同名的全局变量。

3. **带** **​`static`​**​ **关键字的局部静态变量：**

   ```c
   void exampleFunction() {
     // 局部静态变量
     static int localStaticVar = 42;
   }
   int main() {
     // localStaticVar 在这里不可见
   }
   ```

   这样定义的局部静态变量 `localStaticVar`​ 具有函数范围的作用域，即仅在定义它的函数 `exampleFunction`​ 中可见。该变量的生命周期贯穿整个程序的运行时间，而不是仅在 `exampleFunction`​ 被调用时存在。

4. **不带** **​`static`​**​ **关键字的局部静态变量：**

   ```c
   void exampleFunction() {
     // 局部静态变量
     int localStaticVar = 42;
   }
   int main() {
     // localStaticVar 在这里不可见
   }
   ```

   如果去掉 `static`​ 关键字，局部静态变量 `localStaticVar`​ 仍然有函数范围的作用域，但是它的生命周期将限制在 `exampleFunction`​ 被调用的时期。每次调用 `exampleFunction`​ 都会重新初始化这个变量。

   总的来说，带有 `static`​ 关键字的局部静态变量在多次函数调用之间保持其值，具有整个程序运行时间的生命周期。而不带 `static`​ 关键字的局部静态变量在每次函数调用时都会重新初始化，具有函数调用的生命周期。选择取决于变量是否需要在函数调用之间保持其值。

   ‍
