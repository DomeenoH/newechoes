---
title: 基础语法
date: 2024-10-09T18:49:45Z
tags: []
---


### 变量

​`let`​

1. 支持类型推导,也可以显示指定变量类型
2. 变量名用蛇命名法`a_b`​，而枚举和结构体使用帕斯卡命名法`Ab`​
3. 如果变量没有使用可以前置下划线，消除警告
4. 强制类型转换

    let a = 3.1;let b = a as i32
5. 打印变量

    ```rust
    printIn!("val{}",x);
    printIn!("val{x}");
    ```

6. 变量默认不可变
7. 使用`mut`​关键字声明可变

    ```rust
    let mut x=10;
    ```

8. 变量可以解构

### 常量

​`const`​

1. 必须指定类型和值
2. 常量值被直接嵌入生成的底层机器代码中
3. 常量名与静态变量名必须全部大写，单词之间加入下划线
4. 常量的作用域块级作用域，他们只再声明它们的作用域内可见

### 静态变量

​`static`​

1. static 变量是在运行时分配内存
2. 并不是不可修改，可以使用`unsafe`​修改
3. 静态变量的生命周期为整个程序的运行时间

### 解构

### 函数

1. 需要使用蛇形命名法
2. 当用`!`​做返回值，代表永不返回

### 所有权

1. 每一个值都被一个变量所拥有，该变量被称为值的所有权
2. 一个值只能被一个变量拥有
3. 当所有者(变量)离开作用域范围时会被丢弃
4. 有一个基本特征`copy`​，任何基本类型都具有该特征，在给其他值赋值后依旧可用

### 引用与解引用

* 引用

  * 默认不可变引用
  * 用`&`​引用，得到需要引用的地址
  * 可变引用

    1. 先声明可引用
    2. 传参用`mut`​修饰，变成可引用类型

        同一作用域，特定数据只能有一个可变引用
  * 可变引用和不可变引用不能同时存在
  * 引用作用域在最后一次引用的地方
* 解引用

  * 用`*`​解开引用，得到需要引用的数据

### 复合类型

​`unimplemented!()`​在复合类型中为了快速构建框架告诉编译器该函数未实现

### 切片

* 创建方法`[起始位置..结束位置]`​

### 字符

* 字符：Unicode编码
* 字符串：UTF-8编码

  * 追加字符`push`​
  * 追加字符串`push_str`​
  * 修改`insert`​
  * 替换

    * 对原来进行修改`replace`​
    * 返回新字符串，可对自变量使用`replacen`​
  * 删除

    * 删除最后一个字符`pop`​
    * 删除指定位置的字符`remove`​
    * 删除指定位置到结尾的字符`truncate`​
    * 清空`clear`​
  * 链接

    * ​`+`​ `+=`​
    * ​`format!("{}{}",x,y)`​
* 注意区分字符串和字变量
* 字符转义

  ​`\`​
* 保持字符串原样

  ```rust
  r"<str>"
  r#""<str>""# //如果包含双引号
  r###""<str>""###//如果还有歧义可以一直加#
  ```

### 元组

* 长度固定
* 可以多种元素混合
* 可以使用解构或`.`​

### 结构体

​`struct`​

* 可以通过关键词创建结构体
* 可以通过函数返回创建结构体
* 在使用`..<name>`​可以当前结构体没有显示声明的字段，全部从`<name>`​结构体中获得
* 元组结构体，结构体字段没有名称的结构体
* 单元结构体，只定义
* 打印结构体信息

  ```rust
  #[derive(Debug)]
  println!("{:?}", <struct variable>);
  ```

### 枚举

​`enum`​ `enumeration`​

* 也可以用结构体使用
* 枚举用`::`​访问
* 枚举能直接关联数据信息

  ```rust
  enum Message {
      Quit,
      Move { x: i32, y: i32 },
      Write(String),
      ChangeColor(i32, i32, i32),
  }
  ```

* option枚举值用于处理空值

  可以让编译器推断出整个变量是什么类型

  Some(T)：表示成员含有值

  None:成员没有值

### 数组

元素必须相同类型

* 不可变数组

  * 声明可以直接赋值
  * 声明时可以定义类型和长度`let a:[i32;5]`​
* 可变数组

  ​`let arr:&[u16] = &[114,112];`​

### 循环

loop是一个表达式

### 模式

特殊语法，它用于匹配类型中的结构和数据

* match
* if let
* while let
* let
* 忽略模式中

  * 值`_`​
  * 使用下划线本身不会绑定值
* 省略模式`..`​
* 匹配守卫

  位于math分支后的额外if条件，他能为分支提供一个额外的条件,因为他不是模式所以可以寻找外部的值,来使用

### 方法

1. 对象的属性和方法定义是分离的
2. 属性和方法名称相同即可
3. 生成对象的方法一般用`new`​
4. ​`impl`​生成方法
5. ​`struct`​生成属性
6. self

    * ​`self`​：表示该所有权
    * ​`&self`​：`self:&Self`​的简写，对该方法的不可变借用
    * ​`&mut self`​：表示可借用
7. 允许方法名和结构体字段名相同
8. 可以多个`impl`​定义
9. 可以为枚举生成方法

### 闭包

本质上是一个匿名函数

```rust
|param1, param2,...| {
    语句1;
    语句2;
    返回表达式
}
|param1| 返回表达式
```

1. 如果类型推断出一个类型，就不可改变了
2. 闭包可以捕获作用域终端值
3. 闭包特征：`T: Fn(u32) -> u32`​
4. 三种fn特征

    * ​`fnOnce`​

      所有的包自动实现这个特征

      如果没有copy特征，会拿走被捕获变量的所有权

      如果想强制获取捕获变量的所有权，可以在参数列表前添加`move`​关键词
    * ​`fnMut`​

      如果没有移出捕获所有权自动实现这个特征

      可以以借用的方式捕获环境中的值，因此修改该值

      如果想在闭包里面修改可变借用变量，需要把闭包声明为可变类型
    * ​`fn`​

      不需要对捕获变量进行改变的闭包自动实现该特征

      以不可变借用的方法捕获环境中的变量

### 迭代器

特征`IntoIterator`​

* 惰性初始化

  如果不适用不会产生任何的性能损耗
* IntoIterator特征

  显示的转为迭代器

  * ​`into_iter`​：夺走所有权
  * ​`iter`​：借用
  * ​`iter_mut`​：可变借用
* next方法

  会改变迭代器当前的数据

  对迭代器的遍历是消耗性的

  for循环就是通过不断调用next方法
* 适配器

  * 消费型适配器

    该迭代器在内部调用了next方法，会不断的消耗迭代器上的原素
  * 迭代器适配器  
    会返回一个新的迭代器

    迭代器适配器是惰性的所以需要消费者适配器来收尾

    可以将闭包作为参数不仅实现了迭代器环境的处理，还可以捕获环境值
* collect

  消费者迭代器

  使用它可以将一个迭代器的元素收进指定元素中

### 类型转换

* as
* RryInto

  需要导入`use std::convert::TryInto;`​
* 点操作符

  点操作符会发生很多类型转换，最外层的类型不匹配时，会自动引用，自动解引用，强类型转换直到找到需要的特征
* 强类型转换

### type别名

​`type`​

### Sized

每个可定大小都实现了该特征

‍

### 动态大小类型DST

储存在堆上不能直接使用，只能通过引用或`Box`​来间接使用

* 切片
* str

  是String和&str的底层数据

‍

### 智能指针

使用智能指针可以将动态大小类型变成固定大小

* `Box<T>`

  可以将数据存在堆上

  Box::leak：可以消费掉box，并内存泄漏
* Derf特征

  可以实现智能指针的自动解引用

  三种Deref转换

  * ​`T: Deref<Target=U>`​可以将&T转换为&U
  * ​`T: DerefMut<Target=U>`​可以将&mut T转换为&mut U
  * ​`T: Deref<Target=U>`​可以将&mut T转换为&U
* Drop特征

  可以实现资源的回收

  执行一些收尾工作

  和Copy特征互斥

  可以手动收回`Drop()`​
* Rc与Arc

  通过引用器计数

  clone:可以实现浅拷贝，会拿走拷贝指针的所有权

  Arc原子化的智能指针能够保证数据安全，会增加数据损耗
* Cell和RefCell

  提供了内部数据可修改性

  cell只使用于copy类型，没有性能损耗

  RefCell 只是将借用规则从编译期推迟到程序运行期
* Weak

  类似于Rc但是Weak不持有所有权，仅仅保存一份指向数据引用

  不计入所有权，不会阻止释放

  存在返回Some，不存在返回None

### 多线程
